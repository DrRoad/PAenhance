##------ May 17, 2014, 12:37:49 PM ------##

R version 3.1.0 (2014-04-10) -- "Spring Dance"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("C:/Dropbox/hiv_network/workspace/kk_utils/utils.R", echo=FALSE, encoding="Cp1252")
> library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
Loading required package: zoo

Attaching package: 'zoo'

The following objects are masked from 'package:base':

    as.Date, as.Date.numeric

Loading required package: xts

Package PerformanceAnalytics (1.1.4) loaded.
Econometric tools for performance and risk analysis.
(c) 2004-2014 Peter Carl, Brian G. Peterson. License: GPL
http://r-forge.r-project.org/projects/returnanalytics/


Attaching package: 'PerformanceAnalytics'

The following object is masked from 'package:graphics':

    legend

> data(edhec)
> #' Generate general performance table for returns 
> #' 
> #' Main function to produce summary table. user can 
> #' choose a set of metrics and corresponding optional arguments, 
> #' modify metricsnames in output table, all together in data editor 
> #' window from R console. For example, to include SharpeRatio, 
> #' inside the data editor window, locate the row with SharpeRatio, 
> #' and change "include" column from 0 to 1 to include the metric, and then 
> #' change its optional arguments on the right that not with "#" sign. 
> #' "#" sign simply means the argument (column index) is not defined 
> #' for this metric (row index). 
> #' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of
> #' asset returns
> #' @param metrics a character vector of input metrics, use table.Performance.pool() to see 
> #' all the condicate metrics
> #' @param metricsNames options argument to specify metricsNames, default is NULL, 
> #' the same as the metrics
> #' @param interactive logical, default is TRUE, optional argument to trigger data editor window
> #' @param arg.list optional argument to specify input optional argument for each metric, uses 
> #' only interactive=FALSE
> #' @param digits optional argument to specify the significant digits in printed table, default is 4
> #' @param latex logical, default is FALSE, optional arguemnt to output latex code
> #' @param exportFun logical, default is FALSE, optional argument to export function, see details
> #' @details use \code{table.Performance.pool} to check available metrics. recoded SharpeRatio.
> #' Both interactive and fixed input on metric set and optional arguments. Output latex code for resulting table. Export function that uses the same metrics and optional argument from interactive input. 
> #' @author Kirk Li  \email{kirkli@@stat.washington.edu} 
> #' @seealso \code{\link{table.Performance.pool}},\code{\link{table.Performance.pool.cran}},\code{\link{table.Arbitrary}}
> #' @keywords table metrics performance measure
> #' @examples
> #' 
> #' library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> #' data(edhec)
> #' 
> #' # Example 1: start with NULL specification
> #' res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
> #'
> #' # Example 2: start with Var and ES
> #' res.ex2 <- table.Performance(edhec,metrics=c("VaR", "ES"), 
> #' metricsNames=c("Modified VaR","Modified Expected Shortfall"),verbose=T)
> #' 
> #' # Example 3: Non-interactive
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> #' res.ex3 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE,
> #'  arg.list=arg.list, verbose=T, digits=4)
> #' 
> #' # Example 4: Latex code 
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> # 
> #' res.ex4 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE, 
> #' arg.list=arg.list, verbose=T, digits=4, latex=TRUE)
> #'
> #' # Example 5: Export function 
> #' res.ex5 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=TRUE, verbose=T,
> #' digits=4, latex=FALSE, exportFun="myfun1", flag.metricsOptArgVal.export=FALSE)
> #' myfun1(R=edhec)  
> #' # myfun1 uses res.ex5's metrics and optional arguments 
> #' @export
> table.Performance <-
+ function(R,metrics=NULL,metricsNames=NULL, verbose=FALSE, interactive=TRUE, arg.list=NULL, digits=4, latex=FALSE, exportFun=NULL, flag.metricsOptArgVal.export=FALSE,...){
+ 	# FUNCTION: 47-1 different metrics
+ 	pool <- table.Performance.pool()
+ 	
+ #	extract metric functions' arguments
+ 	ArgFormals <- lapply(pool,function(x)formals(x))
+ 	ArgNames <- lapply(ArgFormals,function(x)names(x))
+ 	ArgString.temp <- unique(unlist(ArgNames))
+ 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
+ 	
+ 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
+ 	
+ 	
+ #	loop through each metric and input the default values of args
+ 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
+ 	
+ 	
+ 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
+ #	promote the order of pre-specified metric
+ 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
+ #	open data editor	
+ 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
+ 	# TODO: some improvement can be made here
+ 
+ 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
+ #   process the selected metrics and args	
+ 	metrics.choose <- subset(metrics.vec,include==1)
+ 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
+ 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
+ 	metrics <- as.character(metrics.choose$metrics)
+ 	metricsNames <-  as.character(metrics.choose$metricsNames)
+ 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
+ 	
+ 	
+ 	names(metricsOptArgVal) <- metrics
+ 	
+ 	
+ 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
+ 	
+ 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
+ 	
+ 	
+ #   functions to call each metric function with user input args	
+ 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
+ 	
+ #	generating the table	
+ #	res <- table.Arbitrary.m()
+ 	res <- table.Arbitrary.m(...)
+ #	show printout	
+ 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
+ 	
+ 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
+ 	
+ 	if(!is.null(exportFun)){
+ 		if(!is.character(exportFun))
+ 			warning("exportFun is mis-specified")
+ 		else{
+ 			cat("###################################","\n")
+ 			cat(paste0("Exporting function ",exportFun,"\n"))
+ 			cat("###################################","\n")
+ 			string1 <- paste(exportFun,"<<-","function(R,metrics=",'c(',paste(paste0("'",metrics,"'"),collapse=','),')',", metricsNames=",'c(',paste(paste0("'",metricsNames,"'"),collapse=','),')', ", verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...)")
+ 			string2 <- paste("{table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)}")
+ 			
+ 			eval(parse(text=paste0(string1,string2)))
+ 			
+ 			cat(paste0(string1,string2),"\n")
+ 			cat("###################################","\n")
+ 			
+ 			metricsOptArgVal.export <<- metricsOptArgVal
+ 			
+ 		}
+ 			
+ 	}
+ 	return(res)
+ }
> 
> 
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> data(edhec)
> res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
Error in table.Performance(R = edhec, verbose = T, interactive = TRUE) : 
  could not find function "table.Performance.pool"
> library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> data(edhec)
> res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
Error in table.Performance(R = edhec, verbose = T, interactive = TRUE) : 
  could not find function "table.Performance.pool"
> res.ex2 <- table.Performance(edhec,metrics=c("VaR", "ES"),
+ metricsNames=c("Modified VaR","Modified Expected Shortfall"),verbose=T)
Error in table.Performance(edhec, metrics = c("VaR", "ES"), metricsNames = c("Modified VaR",  : 
  could not find function "table.Performance.pool"
> library(PAenhence)
Error in library(PAenhence) : there is no package called 'PAenhence'
> library(PAenhance)

Attaching package: 'PAenhance'

The following object is masked _by_ '.GlobalEnv':

    table.Performance

The following object is masked from 'package:PerformanceAnalytics':

    SharpeRatio

> R=edhec
> metrics=c("VaR", "ES")
> interactive=TRUE
> verbose=T
> digits=4
> latex=FALSE
> exportFun="myfun1"
> flag.metricsOptArgVal.export=FALSE
> 	pool <- table.Performance.pool()
> 	
> #	extract metric functions' arguments
> 	ArgFormals <- lapply(pool,function(x)formals(x))
> 	ArgNames <- lapply(ArgFormals,function(x)names(x))
> 	ArgString.temp <- unique(unlist(ArgNames))
> 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
> 	
> 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
> 	
> 	
> #	loop through each metric and input the default values of args
> 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
> 	
> 	
> 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
> #	promote the order of pre-specified metric
> 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
> #	open data editor	
> 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
Error: object 'arg.list' not found
> 	# TODO: some improvement can be made here
> 
> 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
> #   process the selected metrics and args	
> 	metrics.choose <- subset(metrics.vec,include==1)
> 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
> 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
> 	metrics <- as.character(metrics.choose$metrics)
> 	metricsNames <-  as.character(metrics.choose$metricsNames)
> 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
> 	
> 	
> 	names(metricsOptArgVal) <- metrics
> 	
> 	
> 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
Error: object 'arg.list' not found
> 	
> 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
Error: object 'arg.list' not found
> 	
> arg.list=NULL
> 	pool <- table.Performance.pool()
> 	
> #	extract metric functions' arguments
> 	ArgFormals <- lapply(pool,function(x)formals(x))
> 	ArgNames <- lapply(ArgFormals,function(x)names(x))
> 	ArgString.temp <- unique(unlist(ArgNames))
> 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
> 	
> 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
> 	
> 	
> #	loop through each metric and input the default values of args
> 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
> 	
> 	
> 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
> #	promote the order of pre-specified metric
> 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
> #	open data editor	
> 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
> 	# TODO: some improvement can be made here
> 
> 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
> #   process the selected metrics and args	
> 	metrics.choose <- subset(metrics.vec,include==1)
> 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
> 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
> 	metrics <- as.character(metrics.choose$metrics)
> 	metricsNames <-  as.character(metrics.choose$metricsNames)
> 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
> 	
> 	
> 	names(metricsOptArgVal) <- metrics
> 	
> 	
> 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
> 	
> 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
> 	
> 	
> #   functions to call each metric function with user input args	
> 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
> 	
> #	generating the table	
> #	res <- table.Arbitrary.m()
> 	res <- table.Arbitrary.m(...)
Error: '...' used in an incorrect context
> #	show printout	
> 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
################################### 
metrics:
[1] "ES"  "VaR"
################################### 
metricsNames:
[1] "ES"  "VaR"
################################### 
metricsOptArg:
Attention: for more than one element in args, 
 only the first one will be used 
Error in print(res$Arg.mat) : object 'res' not found
> 	
> 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
> 	
> 	
> #   functions to call each metric function with user input args	
> 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
> 	
> 	res <- table.Arbitrary.m(...)
Error: '...' used in an incorrect context
> res <- table.Arbitrary.m()
> 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
################################### 
metrics:
[1] "ES"  "VaR"
################################### 
metricsNames:
[1] "ES"  "VaR"
################################### 
metricsOptArg:
Attention: for more than one element in args, 
 only the first one will be used 
$ES
 [1] "clean = c(\"none\", \"boudt\", \"geltner\")"           
 [2] "invert = TRUE"                                         
 [3] "m3 = NULL"                                             
 [4] "m4 = NULL"                                             
 [5] "method = c(\"modified\", \"gaussian\", \"historical\")"
 [6] "mu = NULL"                                             
 [7] "operational = TRUE"                                    
 [8] "p = 0.95"                                              
 [9] "portfolio_method = c(\"single\", \"component\")"       
[10] "sigma = NULL"                                          
[11] "weights = NULL"                                        

$VaR
 [1] "clean = c(\"none\", \"boudt\", \"geltner\")"                       
 [2] "invert = TRUE"                                                     
 [3] "m3 = NULL"                                                         
 [4] "m4 = NULL"                                                         
 [5] "method = c(\"modified\", \"gaussian\", \"historical\", \"kernel\")"
 [6] "mu = NULL"                                                         
 [7] "p = 0.95"                                                          
 [8] "portfolio_method = c(\"single\", \"component\", \"marginal\")"     
 [9] "sigma = NULL"                                                      
[10] "weights = NULL"                                                    

################################### 
table:
    Convertible Arbitrage CTA Global Distressed Securities Emerging Markets
ES                -0.0995    -0.0428               -0.0609          -0.1279
VaR               -0.0325    -0.0338               -0.0275          -0.0636
    Equity Market Neutral Event Driven Fixed Income Arbitrage Global Macro
ES                -0.0429      -0.0591                -0.0595      -0.0198
VaR               -0.0113      -0.0281                -0.0247      -0.0155
    Long/Short Equity Merger Arbitrage Relative Value Short Selling
ES            -0.0471          -0.0333        -0.0489       -0.0902
VaR           -0.0304          -0.0149        -0.0193       -0.0743
    Funds of Funds
ES         -0.0462
VaR        -0.0250
> 	
> 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
> 	
> 	if(!is.null(exportFun)){
+ 		if(!is.character(exportFun))
+ 			warning("exportFun is mis-specified")
+ 		else{
+ 			cat("###################################","\n")
+ 			cat(paste0("Exporting function ",exportFun,"\n"))
+ 			cat("###################################","\n")
+ 			string1 <- paste(exportFun,"<<-","function(R,metrics=",'c(',paste(paste0("'",metrics,"'"),collapse=','),')',", metricsNames=",'c(',paste(paste0("'",metricsNames,"'"),collapse=','),')', ", verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...)")
+ 			string2 <- paste("{table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)}")
+ 			
+ 			eval(parse(text=paste0(string1,string2)))
+ 			
+ 			cat(paste0(string1,string2),"\n")
+ 			cat("###################################","\n")
+ 			
+ 			metricsOptArgVal.export <<- metricsOptArgVal
+ 			
+ 		}
+ 			
+ 	}
################################### 
Exporting function myfun1
################################### 
myfun1 <<- function(R,metrics= c( 'ES','VaR' ) , metricsNames= c( 'ES','VaR' ) , verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...){table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)} 
################################### 
> metrics=NULL
> metricsNames=NULL
> R=edhec
> metrics=c("VaR", "ES")
> interactive=TRUE
> verbose=T
> digits=4
> latex=FALSE
> exportFun="myfun1"
> flag.metricsOptArgVal.export=FALSE
> pool <- table.Performance.pool()
> 	
> #	extract metric functions' arguments
> 	ArgFormals <- lapply(pool,function(x)formals(x))
> 	ArgNames <- lapply(ArgFormals,function(x)names(x))
> 	ArgString.temp <- unique(unlist(ArgNames))
> 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
> 	
> 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
> 	
> 	
> #	loop through each metric and input the default values of args
> 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
> 	
> 	
> 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
> #	promote the order of pre-specified metric
> 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
> #	open data editor	
> 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
> 	# TODO: some improvement can be made here
> 
> 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
> #   process the selected metrics and args	
> 	metrics.choose <- subset(metrics.vec,include==1)
> 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
> 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
> 	metrics <- as.character(metrics.choose$metrics)
> 	metricsNames <-  as.character(metrics.choose$metricsNames)
> 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
> 	
> 	
> 	names(metricsOptArgVal) <- metrics
> 	
> 	
> 
> 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
> 	
> arg.list
NULL
> f
Error: object 'f' not found
> 
> v
Error: object 'v' not found
> #' Generate general performance table for returns 
> #' 
> #' Main function to produce summary table. user can 
> #' choose a set of metrics and corresponding optional arguments, 
> #' modify metricsnames in output table, all together in data editor 
> #' window from R console. For example, to include SharpeRatio, 
> #' inside the data editor window, locate the row with SharpeRatio, 
> #' and change "include" column from 0 to 1 to include the metric, and then 
> #' change its optional arguments on the right that not with "#" sign. 
> #' "#" sign simply means the argument (column index) is not defined 
> #' for this metric (row index). 
> #' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of
> #' asset returns
> #' @param metrics a character vector of input metrics, use table.Performance.pool() to see 
> #' all the condicate metrics
> #' @param metricsNames options argument to specify metricsNames, default is NULL, 
> #' the same as the metrics
> #' @param interactive logical, default is TRUE, optional argument to trigger data editor window
> #' @param arg.list optional argument to specify input optional argument for each metric, uses 
> #' only interactive=FALSE
> #' @param digits optional argument to specify the significant digits in printed table, default is 4
> #' @param latex logical, default is FALSE, optional arguemnt to output latex code
> #' @param exportFun logical, default is FALSE, optional argument to export function, see details
> #' @details use \code{table.Performance.pool} to check available metrics. recoded SharpeRatio.
> #' Both interactive and fixed input on metric set and optional arguments. Output latex code for resulting table. Export function that uses the same metrics and optional argument from interactive input. 
> #' @author Kirk Li  \email{kirkli@@stat.washington.edu} 
> #' @seealso \code{\link{table.Performance.pool}},\code{\link{table.Performance.pool.cran}},\code{\link{table.Arbitrary}}
> #' @keywords table metrics performance measure
> #' @examples
> #' 
> #' library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> #' data(edhec)
> #' 
> #' # Example 1: start with NULL specification
> #' res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
> #'
> #' # Example 2: start with Var and ES
> #' res.ex2 <- table.Performance(edhec,metrics=c("VaR", "ES"), 
> #' metricsNames=c("Modified VaR","Modified Expected Shortfall"),verbose=T)
> #' 
> #' # Example 3: Non-interactive
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> #' res.ex3 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE,
> #'  arg.list=arg.list, verbose=T, digits=4)
> #' 
> #' # Example 4: Latex code 
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> # 
> #' res.ex4 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE, 
> #' arg.list=arg.list, verbose=T, digits=4, latex=TRUE)
> #'
> #' # Example 5: Export function 
> #' res.ex5 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=TRUE, verbose=T,
> #' digits=4, latex=FALSE, exportFun="myfun1", flag.metricsOptArgVal.export=FALSE)
> #' myfun1(R=edhec)  
> #' # myfun1 uses res.ex5's metrics and optional arguments 
> #' @export
> table.Performance <-
+ function(R,metrics=NULL,metricsNames=NULL, verbose=FALSE, interactive=TRUE, arg.list=NULL, digits=4, latex=FALSE, exportFun=NULL, flag.metricsOptArgVal.export=FALSE,...){
+ 	# FUNCTION: 47-1 different metrics
+ 	pool <- table.Performance.pool()
+ 	
+ #	extract metric functions' arguments
+ 	ArgFormals <- lapply(pool,function(x)formals(x))
+ 	ArgNames <- lapply(ArgFormals,function(x)names(x))
+ 	ArgString.temp <- unique(unlist(ArgNames))
+ 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
+ 	
+ 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
+ 	
+ 	
+ #	loop through each metric and input the default values of args
+ 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
+ 	
+ 	
+ 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
+ #	promote the order of pre-specified metric
+ 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
+ #	open data editor	
+ 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
+ 	# TODO: some improvement can be made here
+ 
+ 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
+ #   process the selected metrics and args	
+ 	metrics.choose <- subset(metrics.vec,include==1)
+ 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
+ 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
+ 	metrics <- as.character(metrics.choose$metrics)
+ 	metricsNames <-  as.character(metrics.choose$metricsNames)
+ 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
+ 	
+ 	
+ 	names(metricsOptArgVal) <- metrics
+ 	
+ 	
+ 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
+ 	
+ 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
+ 	
+ 	
+ #   functions to call each metric function with user input args	
+ 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
+ 	
+ #	generating the table	
+ #	res <- table.Arbitrary.m()
+ 	res <- table.Arbitrary.m(...)
+ #	show printout	
+ 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
+ 	
+ 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
+ 	
+ 	if(!is.null(exportFun)){
+ 		if(!is.character(exportFun))
+ 			warning("exportFun is mis-specified")
+ 		else{
+ 			cat("###################################","\n")
+ 			cat(paste0("Exporting function ",exportFun,"\n"))
+ 			cat("###################################","\n")
+ 			string1 <- paste(exportFun,"<<-","function(R,metrics=",'c(',paste(paste0("'",metrics,"'"),collapse=','),')',", metricsNames=",'c(',paste(paste0("'",metricsNames,"'"),collapse=','),')', ", verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...)")
+ 			string2 <- paste("{table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)}")
+ 			
+ 			eval(parse(text=paste0(string1,string2)))
+ 			
+ 			cat(paste0(string1,string2),"\n")
+ 			cat("###################################","\n")
+ 			
+ 			metricsOptArgVal.export <<- metricsOptArgVal
+ 			
+ 		}
+ 			
+ 	}
+ 	return(res)
+ }
> 
> 
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> #' Generate general performance table for returns 
> #' 
> #' Main function to produce summary table. user can 
> #' choose a set of metrics and corresponding optional arguments, 
> #' modify metricsnames in output table, all together in data editor 
> #' window from R console. For example, to include SharpeRatio, 
> #' inside the data editor window, locate the row with SharpeRatio, 
> #' and change "include" column from 0 to 1 to include the metric, and then 
> #' change its optional arguments on the right that not with "#" sign. 
> #' "#" sign simply means the argument (column index) is not defined 
> #' for this metric (row index). 
> #' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of
> #' asset returns
> #' @param metrics a character vector of input metrics, use table.Performance.pool() to see 
> #' all the condicate metrics
> #' @param metricsNames options argument to specify metricsNames, default is NULL, 
> #' the same as the metrics
> #' @param interactive logical, default is TRUE, optional argument to trigger data editor window
> #' @param arg.list optional argument to specify input optional argument for each metric, uses 
> #' only interactive=FALSE
> #' @param digits optional argument to specify the significant digits in printed table, default is 4
> #' @param latex logical, default is FALSE, optional arguemnt to output latex code
> #' @param exportFun logical, default is FALSE, optional argument to export function, see details
> #' @details use \code{table.Performance.pool} to check available metrics. recoded SharpeRatio.
> #' Both interactive and fixed input on metric set and optional arguments. Output latex code for resulting table. Export function that uses the same metrics and optional argument from interactive input. 
> #' @author Kirk Li  \email{kirkli@@stat.washington.edu} 
> #' @seealso \code{\link{table.Performance.pool}},\code{\link{table.Performance.pool.cran}},\code{\link{table.Arbitrary}}
> #' @keywords table metrics performance measure
> #' @examples
> #' 
> #' library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> #' data(edhec)
> #' 
> #' # Example 1: start with NULL specification
> #' res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
> #'
> #' # Example 2: start with Var and ES
> #' res.ex2 <- table.Performance(edhec,metrics=c("VaR", "ES"), 
> #' metricsNames=c("Modified VaR","Modified Expected Shortfall"),verbose=T)
> #' 
> #' # Example 3: Non-interactive
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> #' res.ex3 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE,
> #'  arg.list=arg.list, verbose=T, digits=4)
> #' 
> #' # Example 4: Latex code 
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> # 
> #' res.ex4 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE, 
> #' arg.list=arg.list, verbose=T, digits=4, latex=TRUE)
> #'
> #' # Example 5: Export function 
> #' res.ex5 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=TRUE, verbose=T,
> #' digits=4, latex=FALSE, exportFun="myfun1", flag.metricsOptArgVal.export=FALSE)
> #' myfun1(R=edhec)  
> #' # myfun1 uses res.ex5's metrics and optional arguments 
> #' @export
> table.Performance <-
+ function(R,metrics=NULL,metricsNames=NULL, verbose=FALSE, interactive=TRUE, arg.list=NULL, digits=4, latex=FALSE, exportFun=NULL, flag.metricsOptArgVal.export=FALSE,...){
+ 	# FUNCTION: 47-1 different metrics
+ 	pool <- table.Performance.pool()
+ 	
+ #	extract metric functions' arguments
+ 	ArgFormals <- lapply(pool,function(x)formals(x))
+ 	ArgNames <- lapply(ArgFormals,function(x)names(x))
+ 	ArgString.temp <- unique(unlist(ArgNames))
+ 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
+ 	
+ 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
+ 	
+ 	
+ #	loop through each metric and input the default values of args
+ 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
+ 	
+ 	
+ 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
+ #	promote the order of pre-specified metric
+ 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
+ #	open data editor	
+ 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
+ 	# TODO: some improvement can be made here
+ 
+ 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
+ #   process the selected metrics and args	
+ 	metrics.choose <- subset(metrics.vec,include==1)
+ 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
+ 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
+ 	metrics <- as.character(metrics.choose$metrics)
+ 	metricsNames <-  as.character(metrics.choose$metricsNames)
+ 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
+ 	
+ 	
+ 	names(metricsOptArgVal) <- metrics
+ 	
+ 	
+ 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
+ 	
+ 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
+ 	
+ 	
+ #   functions to call each metric function with user input args	
+ 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
+ 	
+ #	generating the table	
+ #	res <- table.Arbitrary.m()
+ 	res <- table.Arbitrary.m(...)
+ #	show printout	
+ 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
+ 	
+ 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
+ 	
+ 	if(!is.null(exportFun)){
+ 		if(!is.character(exportFun))
+ 			warning("exportFun is mis-specified")
+ 		else{
+ 			cat("###################################","\n")
+ 			cat(paste0("Exporting function ",exportFun,"\n"))
+ 			cat("###################################","\n")
+ 			string1 <- paste(exportFun,"<<-","function(R,metrics=",'c(',paste(paste0("'",metrics,"'"),collapse=','),')',", metricsNames=",'c(',paste(paste0("'",metricsNames,"'"),collapse=','),')', ", verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...)")
+ 			string2 <- paste("{table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)}")
+ 			
+ 			eval(parse(text=paste0(string1,string2)))
+ 			
+ 			cat(paste0(string1,string2),"\n")
+ 			cat("###################################","\n")
+ 			
+ 			metricsOptArgVal.export <<- metricsOptArgVal
+ 			
+ 		}
+ 			
+ 	}
+ 	return(res)
+ }
> 
> 
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> options(width = 88L)
> options(width = 88L)
> dd
Error: object 'dd' not found
> 
> 
> #' Generate general performance table for returns 
> #' 
> #' Main function to produce summary table. user can 
> #' choose a set of metrics and corresponding optional arguments, 
> #' modify metricsnames in output table, all together in data editor 
> #' window from R console. For example, to include SharpeRatio, 
> #' inside the data editor window, locate the row with SharpeRatio, 
> #' and change "include" column from 0 to 1 to include the metric, and then 
> #' change its optional arguments on the right that not with "#" sign. 
> #' "#" sign simply means the argument (column index) is not defined 
> #' for this metric (row index). 
> #' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of
> #' asset returns
> #' @param metrics a character vector of input metrics, use table.Performance.pool() to see 
> #' all the condicate metrics
> #' @param metricsNames options argument to specify metricsNames, default is NULL, 
> #' the same as the metrics
> #' @param interactive logical, default is TRUE, optional argument to trigger data editor window
> #' @param arg.list optional argument to specify input optional argument for each metric, uses 
> #' only interactive=FALSE
> #' @param digits optional argument to specify the significant digits in printed table, default is 4
> #' @param latex logical, default is FALSE, optional arguemnt to output latex code
> #' @param exportFun logical, default is FALSE, optional argument to export function, see details
> #' @details use \code{table.Performance.pool} to check available metrics. recoded SharpeRatio.
> #' Both interactive and fixed input on metric set and optional arguments. Output latex code for resulting table. Export function that uses the same metrics and optional argument from interactive input. 
> #' @author Kirk Li  \email{kirkli@@stat.washington.edu} 
> #' @seealso \code{\link{table.Performance.pool}},\code{\link{table.Performance.pool.cran}},\code{\link{table.Arbitrary}}
> #' @keywords table metrics performance measure
> #' @examples
> #' 
> #' library(PerformanceAnalytics,lib="C:/R/R-3.1.0/library_forge")
> #' data(edhec)
> #' 
> #' # Example 1: start with NULL specification
> #' res <- table.Performance(R=edhec,verbose=T, interactive=TRUE)
> #'
> #' # Example 2: start with Var and ES
> #' res.ex2 <- table.Performance(edhec,metrics=c("VaR", "ES"), 
> #' metricsNames=c("Modified VaR","Modified Expected Shortfall"),verbose=T)
> #' 
> #' # Example 3: Non-interactive
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> #' res.ex3 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE,
> #'  arg.list=arg.list, verbose=T, digits=4)
> #' 
> #' # Example 4: Latex code 
> #' arg.list <- list(
> #' 		ES=list(method=c("modified"),
> #' 				p=0.9),
> #' 		VaR=list(method=c("gaussian"))
> #' )
> # 
> #' res.ex4 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=FALSE, 
> #' arg.list=arg.list, verbose=T, digits=4, latex=TRUE)
> #'
> #' # Example 5: Export function 
> #' res.ex5 <- table.Performance(R=edhec,metrics=c("VaR", "ES"), interactive=TRUE, verbose=T,
> #' digits=4, latex=FALSE, exportFun="myfun1", flag.metricsOptArgVal.export=FALSE)
> #' myfun1(R=edhec)  
> #' # myfun1 uses res.ex5's metrics and optional arguments 
> #' @export
> table.Performance <-
+ function(R,metrics=NULL,metricsNames=NULL, verbose=FALSE, interactive=TRUE, arg.list=NULL, digits=4, latex=FALSE, exportFun=NULL, flag.metricsOptArgVal.export=FALSE,...){
+ 	# FUNCTION: 47-1 different metrics
+ 	pool <- table.Performance.pool()
+ 	
+ #	extract metric functions' arguments
+ 	ArgFormals <- lapply(pool,function(x)formals(x))
+ 	ArgNames <- lapply(ArgFormals,function(x)names(x))
+ 	ArgString.temp <- unique(unlist(ArgNames))
+ 	ArgString <- sort(ArgString.temp[-which(ArgString.temp%in%c("R","x","..."))])	
+ 	
+ 	metrics.vec <- data.frame(
+ 			metrics=pool,
+ 			include=rep(0,length(pool)),
+ 			metricsNames=pool,
+ 			stringsAsFactors=FALSE)
+ 	
+ 	
+ #	loop through each metric and input the default values of args
+ 	for (i in paste0("arg_",ArgString))
+ 		eval(parse(text=paste0("metrics.vec$",i,"<- '#'")))
+ 	
+ 	
+ 	for (i in 1:length(pool)){
+ #		i=1
+ 		ArgFormals.i <- ArgFormals[[i]]
+ 		ArgNames.use.i <- names(ArgFormals.i)
+ 		
+ 		for (ii in ArgString){
+ #		ii=ArgString[1]
+ 			if(any(ArgNames.use.i%in%ii)){
+ 				temp <- ArgFormals.i[which(ArgNames.use.i==ii)]
+ 				temp <- ifelse(class(temp[[1]])%in%c("call","NULL"),as.character(temp),temp) 
+ 				metrics.vec[i,paste0("arg_",ii)] <- temp
+ 			}  
+ 		}
+ 	}
+ #	promote the order of pre-specified metric
+ 	if(length(metrics)>0){
+ 		metrics.vec$include[match(metrics,metrics.vec$metrics)] <- 1
+ 		if(is.null(metrics.vec$metricsNames))
+ 			metrics.vec$metricsNames[match(metrics,metrics.vec$metrics)] <- metricsNames
+ 		metrics.vec <- metrics.vec[order(metrics.vec$include,decreasing=T),]
+ 	}
+ #	open data editor	
+ 	if(interactive & !is.null(arg.list))
+ 		stop("Error: either uses interactive method or user input ArgList, not both")
+ 	# TODO: some improvement can be made here
+ 
+ 	if(interactive){
+ 		metrics.vec <- fix(metrics.vec) #allow user to change the input
+ 	} 
+ #   process the selected metrics and args	
+ 	metrics.choose <- subset(metrics.vec,include==1)
+ 	if(nrow(metrics.choose)==0) stop("please specify as least one metric")
+ 	colnames(metrics.choose) <- gsub("arg_","",colnames(metrics.choose))
+ 	metrics <- as.character(metrics.choose$metrics)
+ 	metricsNames <-  as.character(metrics.choose$metricsNames)
+ 	metricsOptArgVal <- 
+ 			lapply(1:nrow(metrics.choose[,-c(1:3),drop=FALSE]),function(x){
+ #						x=2
+ 						xx <- metrics.choose[x,-c(1:3),drop=FALSE]
+ 						xx[is.na(xx)] <- "NA"
+ 						xy <- as.vector(xx[xx!='#'])
+ 						names(xy) <-  names(xx)[xx!='#']
+ 						xy})
+ 	
+ 	
+ 	names(metricsOptArgVal) <- metrics
+ 	
+ 	
+ 	if(!is.null(arg.list)){
+ 		if(!is.list(arg.list)) stop("Input argument arg.list should be a list")
+ 		if(length(setdiff(names(arg.list),names(metricsOptArgVal)))!=0) 
+ 			stop(paste("Mismatch: input argument arg.list for",paste(names(arg.list),collapse=","), ",  but input metrics are",paste(names(metricsOptArgVal),collapse=",")))
+ 		if(!all(unlist(lapply(arg.list,names)) %in% unlist(lapply(metricsOptArgVal,names))))
+ 			stop("Input argument arg.list doesn't match with argument metrics")
+ 		
+ 		metricsOptArgVal <- lapply(arg.list,function(x){
+ 					t1 <- unlist(x)
+ 					t2 <- suppressWarnings(sapply(t1,function(xx){
+ 										if(is.na(as.numeric(xx)))
+ 											paste0("'",xx,"'")
+ 										else {xx}
+ 									}))
+ #			 expected warning when checking wheter input is numeric convertable or not
+ 					names(t2) <- names(x)
+ 					t2
+ 				})
+ 	} 
+ 	
+ 	if(flag.metricsOptArgVal.export & is.null(arg.list)){
+ 		cat("###################################","\n")
+ 		cat("use previous stored optional argument\n")
+ 		cat("###################################","\n")
+ 		metricsOptArgVal <- metricsOptArgVal.export
+ 	}
+ 	
+ 	
+ #   functions to call each metric function with user input args	
+ 	table.Arbitrary.m <- function(...){
+ 		y = checkData(R, method = "zoo")
+ 		columns = ncol(y)
+ 		rows = nrow(y)
+ 		columnnames = colnames(y)
+ 		rownames = rownames(y)
+ 		Arg.mat <- list()
+ 		for (column in 1:columns) {
+ #			 column=1
+ 			x = as.matrix(y[, column])
+ 			values = vector("numeric", 0)
+ 			for (metric in metrics) {
+ #			 metric=metrics[1]
+ 				ArgString.i <- paste(names(metricsOptArgVal[[metric]]),metricsOptArgVal[[metric]],sep=" = ")
+ 				Arg.mat[[metric]] <- ArgString.i
+ 				ArgString.i <- paste(ArgString.i,collapse =", ")
+ 				if(length(ArgString.i)>0 & nchar(ArgString.i)>0)
+ 					newvalue = eval(parse(text=paste0("apply(x, MARGIN = 2, FUN = metric,",ArgString.i,")"))) else
+ 					newvalue = apply(x, MARGIN = 2, FUN = metric) #...
+ 				values = c(values, newvalue)
+ 			}
+ 			if (column == 1) {
+ 				resultingtable = data.frame(Value = values, row.names = metricsNames)
+ 			}
+ 			else {
+ 				nextcolumn = data.frame(Value = values, row.names = metricsNames)
+ 				resultingtable = cbind(resultingtable, nextcolumn)
+ 			}
+ 		}
+ 		names(Arg.mat) <- metrics
+ 		colnames(resultingtable) = columnnames
+ 		return(list(resultingtable=round(resultingtable,digits),
+ 						Arg.mat=Arg.mat))
+ 	}
+ 	
+ #	generating the table	
+ #	res <- table.Arbitrary.m()
+ 	res <- table.Arbitrary.m(...)
+ #	show printout	
+ 	if(verbose){
+ 		cat("###################################","\n")
+ 		cat("metrics:\n")
+ 		print(metrics)
+ 		cat("###################################","\n")
+ 		cat("metricsNames:\n")
+ 		print(metricsNames)
+ 		cat("###################################","\n")
+ 		cat("metricsOptArg:\n")
+ 		cat("Attention: for more than one element in args, \n only the first one will be used","\n")
+ 		print(res$Arg.mat)
+ 		cat("###################################","\n")
+ 		cat("table:\n")
+ 		print(res$resultingtable)
+ 	}
+ 	
+ 	if(latex){
+ 		require(xtable)
+ 		cat("###################################","\n")
+ 		cat("Latex code:\n")
+ 		print(xtable(res$resultingtable,digits=digits,...))
+ 	}
+ 	
+ 	if(!is.null(exportFun)){
+ 		if(!is.character(exportFun))
+ 			warning("exportFun is mis-specified")
+ 		else{
+ 			cat("###################################","\n")
+ 			cat(paste0("Exporting function ",exportFun,"\n"))
+ 			cat("###################################","\n")
+ 			string1 <- paste(exportFun,"<<-","function(R,metrics=",'c(',paste(paste0("'",metrics,"'"),collapse=','),')',", metricsNames=",'c(',paste(paste0("'",metricsNames,"'"),collapse=','),')', ", verbose=FALSE, interactive=FALSE, arg.list=NULL, digits=4, latex = FALSE, exportFun=NULL,metricsOptArgVal.export,...)")
+ 			string2 <- paste("{table.Performance(R=R,metrics=metrics,metricsNames=metricsNames,verbose=verbose,interactive=interactive,arg.list=arg.list,digits=digits,latex=latex,exportFun=exportFun,flag.metricsOptArgVal.export=TRUE,...)}")
+ 			
+ 			eval(parse(text=paste0(string1,string2)))
+ 			
+ 			cat(paste0(string1,string2),"\n")
+ 			cat("###################################","\n")
+ 			
+ 			metricsOptArgVal.export <<- metricsOptArgVal
+ 			
+ 		}
+ 			
+ 	}
+ 	return(res)
+ }
> 
> 
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> 	
> dd
Error: object 'dd' not found
> 
> 
> 
> 
